name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  NODE_VERSION: "20"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build Next.js application
        run: npm run build
        env:
          NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL }}
          NEXT_PUBLIC_API_URL: ${{ vars.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_KAKAO_MAP_API_KEY: ${{ secrets.NEXT_PUBLIC_KAKAO_MAP_API_KEY }}
          NEXT_PUBLIC_COMPANY_ADDRESS: ${{ vars.NEXT_PUBLIC_COMPANY_ADDRESS }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SKIP_DB_QUERIES: "true"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.DEPLOY_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEPLOY_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.DEPLOY_AWS_REGION }}

      - name: Create server.js file
        run: |
          cat > server.js << 'SERVERJS'
          const { createServer } = require('http')
          const { parse } = require('url')
          const next = require('next')

          const dev = process.env.NODE_ENV !== 'production'
          const hostname = '0.0.0.0'
          const port = process.env.PORT || 3000

          const app = next({ dev, hostname, port })
          const handle = app.getRequestHandler()

          app.prepare().then(() => {
            const server = createServer(async (req, res) => {
              try {
                if (req.url === '/health') {
                  res.writeHead(200, { 'Content-Type': 'text/plain' });
                  res.end('OK');
                  return;
                }
                
                const parsedUrl = parse(req.url, true)
                await handle(req, res, parsedUrl)
              } catch (err) {
                console.error('Error occurred handling', req.url, err)
                res.statusCode = 500
                res.end('internal server error')
              }
            })

            server.keepAliveTimeout = 65000
            server.headersTimeout = 66000

            console.log('Keep-Alive settings applied:')
            console.log('   - keepAliveTimeout: ' + server.keepAliveTimeout + 'ms')
            console.log('   - headersTimeout: ' + server.headersTimeout + 'ms')

            server.listen(port, hostname, (err) => {
              if (err) throw err
              console.log('> Ready on http://' + hostname + ':' + port)
              console.log('> Keep-Alive enabled for better HTTPS performance')
            })
          })

          process.on('SIGTERM', () => {
            console.log('SIGTERM received, shutting down gracefully')
            process.exit(0)
          })

          process.on('SIGINT', () => {
            console.log('SIGINT received, shutting down gracefully')
            process.exit(0)
          })
          SERVERJS

      - name: Update package.json
        run: |
          node -e "
          const fs = require('fs');
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          pkg.scripts.start = 'NODE_ENV=production node server.js';
          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
          "

      - name: Create deployment package
        run: |
          mkdir -p deploy-package
          cp -r .next deploy-package/
          cp -r public deploy-package/ 2>/dev/null || echo "No public directory"
          # Prisma removed - using mysql2 package instead
          cp package.json deploy-package/
          cp package-lock.json deploy-package/
          cp server.js deploy-package/
          cp next.config.js deploy-package/ 2>/dev/null || echo "No next.config.js"
          tar -czf deploy-package.tar.gz deploy-package/

      - name: Upload to S3
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          aws s3 cp deploy-package.tar.gz s3://${{ secrets.DEPLOY_S3_BUCKET_NAME }}/production/deploy-${TIMESTAMP}.tar.gz
          aws s3 cp deploy-package.tar.gz s3://${{ secrets.DEPLOY_S3_BUCKET_NAME }}/production/latest.tar.gz

      - name: Setup SSH keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.BASTION_SSH_KEY }}" > ~/.ssh/bastion_key
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/bastion_key ~/.ssh/ec2_key

      - name: Deploy to EC2 via Bastion
        env:
          S3_BUCKET_NAME: ${{ secrets.DEPLOY_S3_BUCKET_NAME }}
          EC2_USER: ${{ secrets.EC2_USER }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_ACCESS_SECRET: ${{ secrets.JWT_ACCESS_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
        run: |
          SSH_COMMAND="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30"

          $SSH_COMMAND -i ~/.ssh/ec2_key \
            -o ProxyCommand="$SSH_COMMAND -i ~/.ssh/bastion_key -W %h:%p ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}" \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_PRIVATE_IP }} bash << 'DEPLOY_SCRIPT'

          # 환경 변수
          S3_BUCKET_NAME="${{ secrets.DEPLOY_S3_BUCKET_NAME }}/production"
          APP_DIR="/apps/tov-homepage"
          SERVICE_NAME="tov-homepage"

          echo "Starting deployment from S3..."

          # Node.js 경로 확인
          NODE_PATH=$(which node)
          echo "Node.js path: $NODE_PATH"

          # 디렉토리 생성
          sudo mkdir -p $APP_DIR
          cd $APP_DIR

          # S3에서 다운로드
          aws s3 cp s3://${S3_BUCKET_NAME}/latest.tar.gz ./

          # PM2로 기존 서비스 중지 (배포 전)
          pm2 stop $SERVICE_NAME || true

          # 디스크 공간 확보 - 3일 이상 된 백업 삭제
          find /apps/tov-homepage -name "backup-*" -type d -mtime +3 -exec rm -rf {} + 2>/dev/null || true

          # 백업
          if [ -d "current" ]; then
            sudo mv current backup-$(date +%Y%m%d%H%M%S)
          fi

          # 압축 해제
          sudo tar -xzf latest.tar.gz
          sudo mv deploy-package current
          sudo rm latest.tar.gz

          # 권한 설정
          sudo chown -R $USER:$USER $APP_DIR/current

          cd $APP_DIR/current

          # 환경변수 파일 생성
          cat > .env << ENVFILE
          NODE_ENV=production
          PORT=3000
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          DATABASE_USER=${{ secrets.DATABASE_USER }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          JWT_ACCESS_SECRET=${{ secrets.JWT_ACCESS_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
          NEXT_PUBLIC_KAKAO_MAP_API_KEY=${{ secrets.NEXT_PUBLIC_KAKAO_MAP_API_KEY }}
          NEXT_PUBLIC_COMPANY_ADDRESS=${{ vars.NEXT_PUBLIC_COMPANY_ADDRESS }}
          NEXT_PUBLIC_APP_URL=https://tov.or.kr
          NEXT_PUBLIC_API_URL=https://tov.or.kr/api

          # AWS S3 Configuration
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}

          # S3 Bucket Configuration (set to 'false' for private bucket with pre-signed URLs)
          AWS_S3_BUCKET_IS_PUBLIC=${{ secrets.AWS_S3_BUCKET_IS_PUBLIC }}

          # Next.js Configuration
          NEXT_PUBLIC_S3_BUCKET_URL=${{ vars.NEXT_PUBLIC_S3_BUCKET_URL }}

          # Gmail 설정
          EMAIL_SERVICE=${{ vars.EMAIL_SERVICE }}
          EMAIL_USER=${{ vars.EMAIL_USER }}
          EMAIL_PASS=${{ vars.EMAIL_PASS }}
          EMAIL_FROM=${{ vars.EMAIL_FROM }}

          ENVFILE

          # Install build dependencies for native modules
          sudo apt-get update
          sudo apt-get install -y build-essential python3 libvips-dev

          # npm 설치
          npm ci --omit=dev

          # Prisma removed - using mysql2 package instead

          # PM2로 기존 프로세스 중지 및 삭제
          pm2 stop $SERVICE_NAME || true
          pm2 delete $SERVICE_NAME || true

          # PM2로 애플리케이션 시작
          cd $APP_DIR/current
          pm2 start npm --name "$SERVICE_NAME" -- start

          # PM2 설정 저장
          pm2 save

          # PM2 startup 설정 (부팅 시 자동 시작)
          pm2 startup systemd -u $USER --hp $HOME | tail -n 1 | sudo bash || true

          # 상태 확인
          sleep 5
          pm2 status
          pm2 logs $SERVICE_NAME --lines 20 --nostream

          # 헬스체크
          sleep 2
          curl -f http://localhost:3000/health || echo "Health check endpoint not ready yet"

          echo "Deployment completed!"

          # .env 파일을 임시로 복사하여 확인 가능하도록 함
          cp .env /tmp/deployed.env || echo "Failed to copy .env"

          DEPLOY_SCRIPT

      - name: Download deployed .env file for verification
        run: |
          SSH_COMMAND="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30"

          # EC2에서 .env 파일 다운로드
          $SSH_COMMAND -i ~/.ssh/ec2_key \
            -o ProxyCommand="$SSH_COMMAND -i ~/.ssh/bastion_key -W %h:%p ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}" \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_PRIVATE_IP }} \
            "cat /tmp/deployed.env" > deployed-env.txt || echo "Failed to download .env"

          echo "=== Deployed .env file content (sensitive values masked) ==="
          if [ -f deployed-env.txt ]; then
            # 민감한 값들을 마스킹하여 출력
            sed -E 's/(PASSWORD|SECRET|KEY|TOKEN)=.*/\1=***MASKED***/g' deployed-env.txt
          else
            echo "No .env file found"
          fi

      - name: Upload deployed .env as artifact
        if: success()
        uses: actions/upload-artifact@v3
        with:
          name: deployed-env-file
          path: deployed-env.txt
          retention-days: 7

      - name: Clean up SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/bastion_key ~/.ssh/ec2_key deployed-env.txt

      - name: Verify deployment
        run: |
          echo "Deployment completed. Please check https://tov.ptax.kr manually."

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
          fi
